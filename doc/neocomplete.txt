*neocomplete.txt*	Next generation of auto completion framework.

Version: 1.1
Author : Shougo <Shougo.Matsu@gmail.com>
License: MIT license  {{{
    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}}}

CONTENTS					*neocomplete-contents*

Introduction		|neocomplete-introduction|
Install			|neocomplete-install|
Interface		|neocomplete-interface|
  Commands		  |neocomplete-commands|
  Variables		  |neocomplete-variables|
    Sources variables	    |neocomplete-sources-variables|
  Key mappings		  |neocomplete-key-mappings|
  Functions		  |neocomplete-functions|
Examples		|neocomplete-examples|
Sources			|neocomplete-sources|
  User sources		  |neocomplete-user-sources|
Create source		|neocomplete-create-source|
  Source attributes       |neocomplete-source-attributes|
  Candidate attributes   |neocomplete-candidate-attributes|
Create filter		|neocomplete-create-filter|
  Filter attributes       |neocomplete-filter-attributes|
FILTERS			|neocomplete-filters|
External sources	|neocomplete-external-sources|
FAQ			|neocomplete-faq|
Changelog		|neocomplete-changelog|

==============================================================================
INTRODUCTION					*neocomplete-introduction*

*neocomplete* is the next generation auto completion framework and a superior
successor of the |neocomplcache| plugin. It provides a keyword completion
system by maintaining a keyword cache of the current buffer. The neocomplete
framework can be customized easily and has a lot more features than Vim's
standard completion.

Note: neocomplete may consume more memory than other plugins do.

Improvements in neocomplete in comparison to |neocomplcache|:

1. Real fuzzy match behavior like |YouCompleteMe| by default.
2. Refactored source interface.
3. Removed legacy interface.
4. Requires |if_lua|.
5. Optimized completion speed.
6. Changed source names.
7. Changed variable names.
8. Added new features.

==============================================================================
INSTALL						*neocomplete-install*

Install prerequisites

In order to use neocomplete, the following prerequisites have to be met:

1. Vim version 7.3.885 or above
2. Vim build with the |if_lua| feature

The following sections describe where to get a Vim version, neocomplete
works with, for your operating system.

On Windows:

For 32bit http://files.kaoriya.net/goto/vim73w32
For 32bit (alternative) http://tuxproject.de/projects/vim/
                        http://wyw.dcweb.cn/#download
For 64bit http://files.kaoriya.net/goto/vim73w64

On Mac:

You can get |if_lua| enabled MacVim versions here:

https://github.com/zhaocai/macvim
http://code.google.com/p/macvim-kaoriya/

Or install it with homebrew:
>
	brew install macvim --with-cscope --with-lua --HEAD
<

On Linux:

As almost all Vim packages offered by distributions are too old, you should
build Vim manually using gnu make and enable |if_lua| in the configuration
step. The following steps show you the general process on how to build Vim:

1. Get the source package
2. Unpack the sources
3. Configure the package (./configure). This step is essential to enable
   the Vim features you like to use.
4. Build the package with gnu make
5. Install the package using your distributions package manager

You can find detailed information on ho to configure and build Vim from source
under following link: http://vim.wikia.com/wiki/Building_Vim. Or follow the
guide on:
https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source

Install the plugin

After you have installed the right version of Vim, you can go on to install
the neocomplete plugin. You can do this in a more old fashioned, manual way
or use a plugin manager like pathogen, vundle, neobundle. The second approach
is the recommended installation method.

Manual:

1. Get the plugin package
2. Extract the files and put them in your Vim directory
   (usually ~/.vim/ or Program Files/Vim/vimfiles on Windows).
3. Execute |:NeoCompleteEnable| command or set following variable in your vimrc >
	let g:neocomplete#enable_at_startup = 1

Package manager:

For instructions on how to set up a Vim package manager see the documentation
of the package manager of your choice. For example after the set up of
neobundle you can install the neocomplete plugin by following steps:

1. Let the plugin manger know about the package (.vimrc) >
	NeoBundle 'Shougo/neocomplete.vim'
<
2. Install the plugin with the install command >
	:NeoBundleInstall
<

						*neocomplete-migration*

In case you are planing to move from neocomplcache to neocomplete there is a
wiki page that offers a migration guide.
https://github.com/Shougo/neocomplete.vim/wiki/neocomplete-migration-guide

						*neocomplete-RECOMMENDATION*

						*neocomplete-asynchronous*

If you have installed the |vimproc| plugin, neocomplete creates the caches
asynchronously. You can find vimproc at: http://github.com/Shougo/vimproc.
The vimproc plugin needs compilation before you can use it. You can find
further information in the vimproc documentation.

						*neocomplete-snippets*

If you like to use the snippet feature with neocomplete you need to install
the neosnippet plugin (https://github.com/Shougo/neosnippet) or UltiSnips
(https://github.com/SirVer/ultisnips).

						*neocomplete-context-filetype*

If you like to use the context filetype feature, you need to install the
context_filetype.vim plugin which you can find under the following repository:
https://github.com/Shougo/context_filetype.vim

==============================================================================
INTERFACE					*neocomplete-interface*

------------------------------------------------------------------------------
COMMANDS 					*neocomplete-commands*

:NeoCompleteEnable				*:NeoCompleteEnable*
		Validate neocomplete and initialize it.
		Warning: Existing cache disappears.

:NeoCompleteDisable				*:NeoCompleteDisable*
		Invalidate neocomplete and clean it up.

:NeoCompleteToggle				*:NeoCompleteToggle*
		Change the lock/unlock state of neocomplete.
		While neocomplete is in locking, you cannot use automatic
		completions.
		Note: This command also enables neocomplete if it is disabled.

:NeoCompleteLock				*:NeoCompleteLock*
		Lock neocomplete.
		While neocomplete is in locking, you cannot use automatic
		completions but can use manual completions.
		The lock status is local to each buffer.
		Note: This command is disabled when neocomplete is disabled.

:NeoCompleteUnlock				*:NeoCompleteUnlock*
		Unlock neocomplete.
		Note: This command is disabled when neocomplete is disabled.

					*:NeoCompleteAutoCompletionLength*
:NeoCompleteAutoCompletionLength {length}
		Change the length of chars to start automatic completion to
		{length}.
		Note: The length value is local to each buffer.

:NeoCompleteClean 				*:NeoCompleteClean*
		Clean files in |g:neocomplete#data_directory|.

:NeoCompleteSetFileType [filetype]		*:NeoCompleteSetFileType*
		Change the filetype to [filetype] in the current buffer.
		This filetype is only used by neocomplete, so syntax
		highlighting and etc stay same.

		Note: You can get the current filetype by
		|neocomplete#get_context_filetype()|


SOURCES COMMANDS 				*neocomplete-sources-COMMANDS*

:NeoCompleteBufferMakeCache [bufname]		*:NeoCompleteBufferMakeCache*
		Make a cache based on the buffer with the name [bufname].
		The command selects the current buffer when you omit
		[bufname].
		If [bufname] is not loaded, neocomplete will open
		[bufname] automatically.
		Note: It may take time considerably for the big buffer.

:NeoCompleteSyntaxMakeCache [filetype]		*:NeoCompleteSyntaxMakeCache*
		Make a cache from the syntax file with [filetype]
		The current buffer's filetype is selected if [filetype]
		is omitted

:NeoCompleteDictionaryMakeCache [filetype]
					*:NeoCompleteDictionaryMakeCache*
		Make a cache from a dictionary file with [filetype].
		Selects the filetype of the current buffer if [filetype] is
		omitted.

:NeoCompleteTagMakeCache		*:NeoCompleteTagMakeCache*
		Make a cache from a tags file in current buffer.

:NeoCompleteIncludeMakeCache [bufname]		*:NeoCompleteIncludeMakeCache*
		Make a cache from an include file in [bufname].
		Selects the current buffer name when the [bufname] is omitted.

------------------------------------------------------------------------------
VARIABLES 					*neocomplete-variables*

					*g:neocomplete#enable_at_startup*
g:neocomplete#enable_at_startup
		neocomplete gets started automatically when Vim starts if
		this value is 1.

		With the default value 0, you cannot use neocomplete
		unless you start it manually.

		Note: This option has to be set in your .vimrc or _vimrc.
		NOT IN the .gvimrc nor _gvimrc!

g:neocomplete#max_list				*g:neocomplete#max_list*
		This variable controls the number of candidates displayed in a
		pop-up menu. If the list of candidates exceeds the limit, not
		all candidates will show up.

		Default value is 100.

					*g:neocomplete#max_keyword_width*
g:neocomplete#max_keyword_width
		This variable controls the indication width of a candidate
		displayed in a pop-up menu. If the keyword length exceeds
		the length it will be cut down properly.

		Default value is 80.

				*g:neocomplete#auto_completion_start_length*
g:neocomplete#auto_completion_start_length
		This variable controls the number of the input completion
		at the time of key input automatically.
		Note: |g:neocomplete#auto_completion_start_length| is used
		for "keyword" kind source only. Please refer to
			|neocomplete-source-attribute-min_pattern_length|.

		Default value is 2.

				*g:neocomplete#manual_completion_start_length*
g:neocomplete#manual_completion_start_length
		This variable controls the number of the input completion
		at the time of manual completion.  It is convenient when you
		reduce this value, but may get heavy when you deleted a
		letter in <C-h> or <BS> at popup indication time.

		Default value is 0.

					*g:neocomplete#min_keyword_length*
g:neocomplete#min_keyword_length
		In a buffer or dictionary files, this variable controls
		length of keyword becoming the targets of the completion at
		the minimum.

		Default value is 4.

					*g:neocomplete#enable_ignore_case*
g:neocomplete#enable_ignore_case
		When neocomplete looks for candidate completion, this
		variable controls whether neocomplete ignores the upper-
		and lowercase.  If it is 1, neocomplete ignores case.

		Default value is 'ignorecase'.

					*g:neocomplete#enable_smart_case*
g:neocomplete#enable_smart_case
		When a capital letter is included in input, neocomplete does
		not ignore the upper- and lowercase.

		Default value is 'infercase'.

					*g:neocomplete#enable_camel_case*
g:neocomplete#enable_camel_case
		When a capital letter is matched with the uppercase, but a
		lower letter is matched with the upper- and lowercase.
		Ex: "foB" is matched with "FooBar" not "foobar".
		Note: This feature is only available in
		|neocomplete-filter-matcher_fuzzy|.

		Default value is 0.

					*g:neocomplete#disable_auto_complete*
g:neocomplete#disable_auto_complete
		This variable controls whether you invalidate automatic
		completion.  If it is 1, automatic completion becomes
		invalid, but can use the manual completion by <C-x><C-u>.

		Default value is 0.

					*g:neocomplete#enable_cursor_hold_i*
g:neocomplete#enable_cursor_hold_i
		This variable controls whether neocomplete use |CursorHoldI|
		event when complete candidates.
		Note: This option must be set before call
		|:NeoCompleteEnable|.

		Default value is 0.

					*g:neocomplete#cursor_hold_i_time*
g:neocomplete#cursor_hold_i_time
		If g:neocomplete#enable_cursor_hold_i is non-zero and in
		insert mode, this value changes 'updatetime' option.

		Default value is 300.

					*g:neocomplete#enable_insert_char_pre*
g:neocomplete#enable_insert_char_pre
		This variable controls whether neocomplete use
		|InsertCharPre| event when complete candidates.
		Note: This option must be set before call
		|:NeoCompleteEnable|.
		Note: If the option is enabled, you cannot continue completion
		by pressing Backspace. It is Vim's feature.
		https://github.com/Shougo/neocomplete.vim/issues/106

		Default value is 0.

					*g:neocomplete#enable_auto_select*
g:neocomplete#enable_auto_select
		When neocomplete displays candidates, this option controls
		whether neocomplete selects the first candidate
		automatically.  If you enable this option, neocomplete's
		completion behavior is like |AutoComplPop|.

		Default value is 0.

				*g:neocomplete#enable_auto_delimiter*
g:neocomplete#enable_auto_delimiter
		This option controls whether neocomplete insert delimiter
		automatically.  For example, /(filename) or #(Vim script).

		Default value is 0.

				*g:neocomplete#enable_fuzzy_completion*
g:neocomplete#enable_fuzzy_completion
		When you input one character, this variable controls whether
		neocomplete takes an ambiguous searching as an end of the
		words in it.  For example, neocomplete comes to match it with
		"public_html" or "PublicHtml" when you input it with "puh".
		Note: The first letter must be matched.

		Default value is 1.

				*g:neocomplete#enable_refresh_always*
g:neocomplete#enable_refresh_always
		If it is non-0, neocomplete always refresh candidates.
		You can get real fuzzy candidates like |YouCompleteMe|.
		Note: This feature is heavy.

		Default value is 0.

				*g:neocomplete#lock_buffer_name_pattern*
g:neocomplete#lock_buffer_name_pattern
		This variable sets a pattern of the buffer name.  If matched it,
		neocomplete does not complete automatically.  When it is an
		empty character string, neocomplete will ignore it.

		Default value is ''.

g:neocomplete#enable_prefetch		*g:neocomplete#enable_prefetch*
		This variable controls whether neocomplete prefetches.  If
		this variable is non-zero, neocomplete does not flick in
		auto completion.

		Note: This variable has a side effect.  Partial function (ex:
		|complete_check()|) is disabled in completefunc.
		Note: If this variable is 0, an input problem may occur in
		using uim-skk or other IMEs on GVim.

		Default value is 1 (|+xim| and GUI version.)
		Default value is 0 (Others)

g:neocomplete#lock_iminsert		*g:neocomplete#lock_iminsert*
		If this variable is non-zero, neocomplete locks when
		'iminsert' is non-zero.

		Default value is 0.

g:neocomplete#data_directory		*g:neocomplete#data_directory*
		This variable appoints the directory that neocomplete
		begins to write a file at one time.  When there is not the
		directory which appointed here, it is made.  For example,
		buffer.vim stores cache of the keyword in this
		'buffer_cache' sub directory.

		Default value is '~/.cache/neocomplete'.

					*g:neocomplete#keyword_patterns*
g:neocomplete#keyword_patterns
		This dictionary records keyword patterns to completion.
		This is appointed in regular expression every file type.
		If the key is "_" or "default", it is used for default
		pattern.

		Because it is complicated, refer to
		neocomplete#init#_variables() in
		autoload/neocomplete/init.vim for the initial value.
>
		" Examples:
		if !exists('g:neocomplete#keyword_patterns')
		  let g:neocomplete#keyword_patterns = {}
		endif
		let g:neocomplete#keyword_patterns._ = '\h\w*'
<
				*g:neocomplete#force_omni_input_patterns*
g:neocomplete#force_omni_input_patterns
		This dictionary records keyword patterns to Omni completion.
		This is appointed in regular expression every file type.
		If this pattern is not defined or empty pattern, neocomplete
		does not call 'omnifunc'.
		Note: If it is a set, neocomplete will call 'omnifunc'
		directly.  So almost neocomplete features are disabled(for
		example: auto select first candidate).  But
		all Omni completion works instead of
		|g:neocomplete#sources#omni#input_patterns|.
>
		if !exists('g:neocomplete#force_omni_input_patterns')
		  let g:neocomplete#force_omni_input_patterns = {}
		endif
		let g:neocomplete#force_omni_input_patterns.ruby =
		\ '[^. *\t]\.\w*\|\h\w*::'
<
		Because it is complicated, refer to
		neocomplete#init#_variables() in
		autoload/neocomplete/init.vim for the initial value.

					*g:neocomplete#same_filetypes*
g:neocomplete#same_filetypes
		It is a dictionary to connect file type mutually.  It is
		effective at time to let you refer to c and cpp mutually.
		The value are comma-separated filetypes.
		If the value contains "_", neocomplete completes from all
		buffers.  If the key is "_", the value will be used for default
		same filetypes.
		Note: neocomplete completes from same filetype buffers in
		default.
>
		if !exists('g:neocomplete#same_filetypes')
		  let g:neocomplete#same_filetypes = {}
		endif
		" In c buffers, completes from cpp and d buffers.
		let g:neocomplete#same_filetypes.c = 'cpp,d'
		" In cpp buffers, completes from c buffers.
		let g:neocomplete#same_filetypes.cpp = 'c'
		" In gitconfig buffers, completes from all buffers.
		let g:neocomplete#same_filetypes.gitconfig = '_'
		" In default, completes from all buffers.
		let g:neocomplete#same_filetypes._ = '_'
<
		Because it is complicated, refer to
		neocomplete#init#_variables() in
		autoload/neocomplete/init.vim for the initial value.
		Note: To disable neocomplete initialization, you must use
		|neocomplete#disable_default_dictionary()|.


					*g:neocomplete#text_mode_filetypes*
g:neocomplete#text_mode_filetypes
		It is a dictionary to define text mode filetypes.  The
		dictionary's key is filetype and value is number.  If the
		value is non-zero, this filetype is text mode.  In text mode,
		neocomplete supports word conversion to write English.

		For example, if you input "Fo", neocomplete will convert
		candidate "foo" to "Foo".  If you input "foo", neocomplete
		will convert candidate "FooBar" to "foobar".  If you input
		"FO", neocomplete will convert candidate "foo" to "FOO".
		Note: Text mode conversion is only used for "foobar" or
		"Foobar" or "FOOBAR" words.  Not "fooBar" or "FooBar".

		Because it is complicated, refer to
		neocomplete#init#_variables() in
		autoload/neocomplete/init.vim for the initial value.

g:neocomplete#ctags_command		*g:neocomplete#ctags_command*
		It is the path to the ctags command.
		Note: If this command is not installed, include source is
		disabled.

		Default value is "ctags".

					*g:neocomplete#ctags_arguments*
g:neocomplete#ctags_arguments
		It is the dictionary of the character string to set a value
		to give as an argument of the commands when buffer
		and include use a ctags command.  The dictionary's
		key is filetype.  If the key is "_", it will be used for
		default.

		Because it is complicated, refer to
		neocomplete#init#_variables() in
		autoload/neocomplete/init.vim for the initial value.

					*g:neocomplete#delimiter_patterns*
g:neocomplete#delimiter_patterns
		This variable appoints a delimiter pattern to smart complete a
		function.  This is appointed in string list every file type.
		Note: This string is not regular expression.
>
		" Examples:
		if !exists('g:neocomplete#delimiter_patterns')
		let g:neocomplete#delimiter_patterns= {}
		endif
		let g:neocomplete#delimiter_patterns.vim = ['#']
		let g:neocomplete#delimiter_patterns.cpp = ['::']
<
		Because it is complicated, refer to
		neocomplete#init#_variables() in
		autoload/neocomplete/init.vim for the initial value.

g:neocomplete#sources			*g:neocomplete#sources*
		It is a dictionary to decide use source names.  The key is
		filetype and the value is source names list.  If the key is
		"_", the value will be used for default filetypes.  For
		example, you can disable some sources in C++ filetype.
		If the value is "_", it will load all sources.
		Default value is {}.
>
		" Examples:
		if !exists('g:neocomplete#sources')
		  let g:neocomplete#sources = {}
		endif
		let g:neocomplete#sources._ = ['buffer']
		let g:neocomplete#sources.cpp = ['buffer', 'include']
<
b:neocomplete_sources			*b:neocomplete_sources*
		It is a list to decide use source names in buffer local.
>
		" Examples:
		" In cmdwin, only use vim source.
		autocmd CmdwinEnter * let b:neocomplete_sources = ['vim']
<
				*g:neocomplete#force_overwrite_completefunc*
g:neocomplete#force_overwrite_completefunc
		If this variable is 1, neocomplete forces to overwrite
		'completefunc' option.  This variable is useful for other
		plugin overwrite 'completefunc'.  But other plugin's
		'completefunc' is disabled.

		Default value is 0.

					*g:neocomplete#release_cache_time*
g:neocomplete#release_cache_time
		This variable defines time of automatic released cache by a
		second unit.

		Default value is 900.

					*g:neocomplete#tags_filter_patterns*
g:neocomplete#tags_filter_patterns
		This dictionary records a pattern to filter a candidate in
		the tag completion.  For example, it can exclude a candidate
		beginning in _ in file type of C/C++.

		Because it is complicated, refer to
		neocomplete#init#_variables() in
		autoload/neocomplete/init.vim for the initial value.

g:neocomplete#use_vimproc			*g:neocomplete#use_vimproc*
		This variable is non 0, neocomplete uses |vimproc|.
		Note: If this variable is non 0, neocomplete will make cache
		asynchronously.

		Default value is vimproc auto detection result.

				*g:neocomplete#ignore_composite_filetypes*
g:neocomplete#ignore_composite_filetypes
		It is a dictionary to ignore composite file type.
		The dictionary's key is composite filetype and value is
		filetype.
>
		" Examples:
		let g:neocomplete#ignore_composite_filetypes = {
			\ 'ruby.spec' : 'ruby'
			\ }
<
		If you open filetype like "ruby.spec", completion is
		intended for "ruby" and "spec".
		But if you only want to complete "ruby" filetype,
		you can set this variable to ignore "spec".

		Default value is {}.

				*g:neocomplete#skip_auto_completion_time*
g:neocomplete#skip_auto_completion_time
		It is a string for skip auto completion.
		If completion time is higher than it, neocomplete will skip
		auto completion.
		If it is "", the skip feature will be disabled.

		Default value is "0.3".
		{only available when compiled with the |+reltime| feature}

				*g:neocomplete#enable_auto_close_preview*
g:neocomplete#enable_auto_close_preview
		If it is non-zero, neocomplete will close preview window
		automatically.

		Default value is 1.

SOURCES VARIABLES 			*neocomplete-sources-variables*

			*g:neocomplete#sources#buffer#cache_limit_size*
g:neocomplete#sources#buffer#cache_limit_size
		This variable sets file size to make a cache of a file.  If
		open file is bigger than this size, neocomplete does not
		make a cache.

		Default value is 500000.

			*g:neocomplete#sources#buffer#disabled_pattern*
g:neocomplete#sources#buffer#disabled_pattern
		This variable sets a pattern of the buffer file path.  If
		matched it, neocomplete does not save a cache of the buffer.
		When it is an empty character string, neocomplete will
		ignore.

		Default value is ''.

			*g:neocomplete#sources#buffer#max_keyword_width*
g:neocomplete#sources#buffer#max_keyword_width
		If the keyword length exceeds the length it will be not shown
		in popup menu.

		Default value is 80.

			*g:neocomplete#sources#dictionary#dictionaries*
g:neocomplete#sources#dictionary#dictionaries
		It is a dictionary to connect a dictionary file with file
		type.  The dictionary's key is filetype and comma-separated
		multiple value is a path to a dictionary file.  If this
		variable is empty, neocomplete uses 'dictionary' option.
		When you set "text" key, you will appoint dictionary files in
		text mode.  If the key is "_", it is loaded in every filetype.
		Note: Global 'dictionary' file is not loaded automatically.

		Default value is {}.

			*g:neocomplete#sources#dictionary#keyword_patterns*
g:neocomplete#sources#dictionary#keyword_patterns
		This option is deleted. You must use
		|neocomplete-source-attribute-keyword_patterns|.

				*g:neocomplete#sources#file_include#exprs*
g:neocomplete#sources#file_include#exprs
		It is the expression string of the line analysis to perform
		to substitute an include file name.  When there is not it,
		ignored.  Refer to 'includeexpr' for the
		description form.  It is the dictionary of the character
		string that assumed file type a key.

		Example: Perl
>
		if !exists('g:neocomplete#sources#file_include#exprs')
		  let g:neocomplete#sources#file_include#exprs = {}
		endif
		let g:neocomplete#sources#file_include#exprs.perl =
		\ 'fnamemodify(substitute(v:fname, "/", "::", "g"), ":r")'
<

		Because it is complicated, refer to s:source.initialize() in
		autoload/neocomplete/sources/file.vim for the
		initial value.

				*g:neocomplete#sources#file_include#exts*
g:neocomplete#sources#file_include#exts
		It is the list of include file name extensions.  When there
		is not it, all file name is used.  It is the dictionary of
		the list that assumed file type a key.  In order to use this
		feature you have to initialize
		'g:neocomplete#sources#file_include#exts' as shown in the
		following example.

		Example: C++
>
		if !exists('g:neocomplete#sources#file_include#exts')
		  let g:neocomplete#sources#file_include#exts = {}
		endif
		let g:neocomplete#sources#file_include#exts.cpp =
		\ ['', 'h', 'hpp', 'hxx']
<
		Because it is complicated, refer to s:source.initialize() in
		autoload/neocomplete/sources/file.vim for the
		initial value.

				*g:neocomplete#sources#file_include#delimiters*
g:neocomplete#sources#file_include#delimiters
		It is the delimiter character of include path.  When there is
		not it, "." is used.  It is the dictionary of the string that
		assumed file type a key.

		Because it is complicated, refer to s:source.initialize() in
		autoload/neocomplete/sources/file.vim for the
		initial value.

					*g:neocomplete#sources#include#paths*
g:neocomplete#sources#include#paths
		It is the variable to enumerate path of the include file
		every file type.  When there is not it, 'path' is used.
		Refer to 'path' for the description form.  It is the
		dictionary of the character string that assumed file type a
		key.

		Because it is complicated, refer to s:source.initialize() in
		autoload/neocomplete/sources/include.vim for the
		initial value.

					*g:neocomplete#sources#include#exprs*
g:neocomplete#sources#include#exprs
		It is the expression string of the line analysis to perform
		to acquire an include file name.  When there is not it,
		'includeexpr' is used.  Refer to 'includeexpr' for the
		description form.  It is the dictionary of the character
		string that assumed file type a key.

		Because it is complicated, refer to s:source.initialize() in
		autoload/neocomplete/sources/include.vim for the
		initial value.

				*g:neocomplete#sources#include#patterns*
g:neocomplete#sources#include#patterns
		This variable appoints the pattern of the include command.
		When there is not it, 'include' is used.  Refer to 'include'
		for the description form.  It is the dictionary of the
		character string that assumed file type a key.

		Because it is complicated, refer to s:source.initialize() in
		autoload/neocomplete/sources/include.vim for the
		initial value.

				*g:neocomplete#sources#include#functions*
g:neocomplete#sources#include#functions
		This variable appoints the function name of the include
		command.  When there is not it, ignored.  It is the dictionary
		of the function name string that assumed file type a key.

		The function args are {lines} and {path}.
		{lines} is the list of buffer lines.
		{path} is the include path.
		The return value is the list of include files.

		Because it is complicated, refer to s:source.initialize() in
		autoload/neocomplete/sources/include.vim for the
		initial value.

				*g:neocomplete#sources#include#max_processes*
g:neocomplete#sources#include#max_processes
		This variable appoints the max number of include processes.
		When this variable is 0, include process will be disabled.

		Default value is 20.

			*g:neocomplete#sources#syntax#min_keyword_length*
g:neocomplete#sources#syntax#min_keyword_length
		In syntax files, this variable controls length of keyword
		becoming the object of the completion at the minimum.

		Default value is 4.

				*g:neocomplete#sources#member#prefix_patterns*
g:neocomplete#sources#member#prefix_patterns
		This variable appoints a prefix pattern to complete a member
		in buffer.
		This is appointed in regular expression every file type.
		If filetype key is not set, disable member completion.

		Because it is complicated, refer in
		autoload/neocomplete/sources/buffer.vim for the
		initial value.

				*g:neocomplete#sources#member#input_patterns*
g:neocomplete#sources#member#input_patterns
		This variable appoints a keyword pattern to complete a member
		in buffer.
		This is appointed in regular expression every file type.
		If filetype key is not set, use filetype "_" setting.

		Because it is complicated, refer in
		autoload/neocomplete/sources/buffer.vim for the
		initial value.

				*g:neocomplete#sources#omni#functions*
g:neocomplete#sources#omni#functions
		This dictionary which appoints omni source call functions.
		The key is |&filetype|.  The value is omnifunc name String or
		List of omnifunc name String.
		If |g:neocomplete#sources#omni#functions| [|&filetype|] is
		undefined, omni source calls 'omnifunc'.
		If the key is "_", used for all filetypes.

		Default value is {}.

				*g:neocomplete#sources#omni#input_patterns*
g:neocomplete#sources#omni#input_patterns
		This dictionary records keyword patterns used in
		omni source.  This is appointed in regular expression
		every file type or 'omnifunc' name.  If this pattern is not
		defined or empty pattern, neocomplete does not call
		'omnifunc'.
		Note: ruby and php omnifunc are disabled, because they are too
		slow.
		Note: Partial omnifunc has problem when neocomplete call(Ex:
		rubycomplete, jedi.vim, cocoa.vim and clang_complete).  You
		should |g:neocomplete#force_omni_input_patterns| instead.

		Because it is complicated, refer to s:source.initialize()
		autoload/neocomplete/sources/omni.vim for the
		initial value.
>
		" Examples:
		if !exists('g:neocomplete#sources#omni#input_patterns')
		  let g:neocomplete#sources#omni#input_patterns = {}
		endif
		let g:neocomplete#sources#omni#input_patterns.php =
		\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
		let g:neocomplete#sources#omni#input_patterns.c =
		\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
<
				*g:neocomplete#sources#tags#cache_limit_size*
g:neocomplete#sources#tags#cache_limit_size
		This variable sets file size to make a cache of a file in
		tag source.  If open file is bigger than this size,
		neocomplete does not make a tags cache.

		Default value is 500000.

				*g:neocomplete#sources#vim#complete_functions*
g:neocomplete#sources#vim#complete_functions
		This dictionary which appoints vim source call function
		when completes custom and customlist command.  The key is
		command name.  The value is function name.

		Default value is {}.
>
		" Examples:
		if !exists('g:neocomplete#sources#vim#complete_functions')
		  let g:neocomplete#sources#vim#complete_functions = {}
		endif
		let g:neocomplete#sources#vim#complete_functions.Ref =
		\ 'ref#complete'
<
					 *g:neocomplete#ignore_source_files*
g:neocomplete#ignore_source_files
		Ignore source filenames(not full path). You can optimize
		source initialization.

		Note: You cannot use the sources in ignored source files.
>
  let g:neocomplete#ignore_source_files = ['tag.vim']
<
		The default value is [].

------------------------------------------------------------------------------
FUNCTIONS 					*neocomplete-functions*

neocomplete#initialize()			*neocomplete#initialize()*
		Initialize neocomplete and sources.
		Note: It enables neocomplete.
		Note: You should call it in |VimEnter| autocmd.
		User customization for neocomplete must be set before
		initialization of neocomplete.

neocomplete#custom#source({source-name}, {option-name}, {value})
						*neocomplete#custom#source()*
		Set {source-name} source specialized {option-name}
		to {value}. You may specify multiple sources with
		separating "," in {source-name}.
		If {source-name} is "_", sources default option will be
		change.

		These options below are available:
		|neocomplete-source-attributes|
		Note: User customization for neocomplete must be set before
		initialization of neocomplete.

						*neocomplete#custom_source()*
		neocomplete#custom_source() is used for compatibility.

					*neocomplete#get_context_filetype()*
neocomplete#get_context_filetype()
		Get current context filetype of the cursor.  This is smarter
		than 'filetype' about handling nested filetypes.
		Note: To enable context filetype feature, you must install
		context_filetype.vim.
		https://github.com/Shougo/context_filetype.vim

		For example html filetype has javascript inside.  Say, you have
		a buffer which content is below with filetype is html.
>
		<script type="text/javascript">
		  var x = 1;
		</script>
<
		At the line 1 and 3, neocomplete#get_context_filetype() is
		"html" and at the line 2 it's "javascript", while at any
		lines 'filetype' is "html".

				*neocomplete#disable_default_dictionary()*
neocomplete#disable_default_dictionary({variable-name})
		Disable default {variable-name} dictionary initialization.
		Note: It must be called in .vimrc.
>
	call neocomplete#disable_default_dictionary(
	      \ 'g:neocomplete#same_filetypes')
<
------------------------------------------------------------------------------
KEY MAPPINGS 					*neocomplete-key-mappings*

				*neocomplete#start_manual_complete()*
neocomplete#start_manual_complete([{sources}])
		Use this function on inoremap <expr>.  The keymapping call the
		completion of neocomplete.  When you rearrange the completion
		of the Vim standard, you use it.
		If you give {sources} argument, neocomplete call {sources}.
		{sources} is name of source or list of sources name.
>
		inoremap <expr><Tab>  neocomplete#start_manual_complete()
<
				*neocomplete#close_popup()*
neocomplete#close_popup()
		Insert candidate and close popup menu for neocomplete.
>
		inoremap <expr><C-y>  neocomplete#close_popup()
<
				*neocomplete#cancel_popup()*
neocomplete#cancel_popup()
		Cancel completion menu for neocomplete.
>
		inoremap <expr><C-e>  neocomplete#cancel_popup()
<
				*neocomplete#smart_close_popup()*
neocomplete#smart_close_popup()
		Insert candidate and re-generate popup menu for neocomplete.
		Unlike |neocomplete#close_popup()|, this function changes
		behavior by |g:neocomplete#enable_auto_select| smart.
		Note: This mapping is conflicted with |SuperTab| or |endwise|
		plugins.
		Note: This key mapping is for <C-h> or <BS> keymappings.
		You should not use it for <CR>.

				*neocomplete#undo_completion()*
neocomplete#undo_completion()
		Use this function on inoremap <expr> to undo inputted
		candidate.  Because there is not mechanism to cancel
		candidate in Vim, it will be convenient when it inflects.
>
		inoremap <expr><C-g>     neocomplete#undo_completion()
<
				*neocomplete#complete_common_string()*
neocomplete#complete_common_string()
		Use this function on inoremap <expr> to complete common
		string in candidates.  It will be convenient when candidates
		have long common string.
>
		inoremap <expr><C-l>     neocomplete#complete_common_string()
<
				*<Plug>(neocomplete_start_unite_complete)*
<Plug>(neocomplete_start_unite_complete)
		Start completion with |unite|.
		Note: unite.vim Latest ver.3.0 or above is required.
		Note: In unite interface, uses partial match instead of head
		match.

				*<Plug>(neocomplete_start_quick_match)*
<Plug>(neocomplete_start_unite_quick_match)
		Start completion with |unite| and start quick match mode.
		Note: unite.vim Latest ver.3.0 or above is required.

==============================================================================
EXAMPLES					*neocomplete-examples*
>
	" Note: This option must set it in .vimrc(_vimrc).
	" NOT IN .gvimrc(_gvimrc)!
	" Disable AutoComplPop.
	let g:acp_enableAtStartup = 0
	" Use neocomplete.
	let g:neocomplete#enable_at_startup = 1
	" Use smartcase.
	let g:neocomplete#enable_smart_case = 1
	" Set minimum syntax keyword length.
	let g:neocomplete#sources#syntax#min_keyword_length = 3
	let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

	" Define dictionary.
	let g:neocomplete#sources#dictionary#dictionaries = {
	    \ 'default' : '',
	    \ 'vimshell' : $HOME.'/.vimshell_hist',
	    \ 'scheme' : $HOME.'/.gosh_completions'
	    \ }

	" Define keyword.
	if !exists('g:neocomplete#keyword_patterns')
	    let g:neocomplete#keyword_patterns = {}
	endif
	let g:neocomplete#keyword_patterns['default'] = '\h\w*'

	" Plugin key-mappings.
	inoremap <expr><C-g>     neocomplete#undo_completion()
	inoremap <expr><C-l>     neocomplete#complete_common_string()

	" Recommended key-mappings.
	" <CR>: close popup and save indent.
	inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
	function! s:my_cr_function()
	  return neocomplete#close_popup() . "\<CR>"
	  " For no inserting <CR> key.
	  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
	endfunction
	" <TAB>: completion.
	inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
	" <C-h>, <BS>: close popup and delete backword char.
	inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr><C-y>  neocomplete#close_popup()
	inoremap <expr><C-e>  neocomplete#cancel_popup()
	" Close popup by <Space>.
	"inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

	" For cursor moving in insert mode(Not recommended)
	"inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
	"inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
	"inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
	"inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
	" Or set this.
	"let g:neocomplete#enable_cursor_hold_i = 1
	" Or set this.
	"let g:neocomplete#enable_insert_char_pre = 1

	" AutoComplPop like behavior.
	"let g:neocomplete#enable_auto_select = 1

	" Shell like behavior(not recommended).
	"set completeopt+=longest
	"let g:neocomplete#enable_auto_select = 1
	"let g:neocomplete#disable_auto_complete = 1
	"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

	" Enable omni completion.
	autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
	autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
	autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
	autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
	autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

	" Enable heavy omni completion.
	if !exists('g:neocomplete#sources#omni#input_patterns')
	  let g:neocomplete#sources#omni#input_patterns = {}
	endif
	if !exists('g:neocomplete#force_omni_input_patterns')
	  let g:neocomplete#force_omni_input_patterns = {}
	endif
	"let g:neocomplete#sources#omni#input_patterns.php =
	"\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
	"let g:neocomplete#sources#omni#input_patterns.c =
	"\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
	"let g:neocomplete#sources#omni#input_patterns.cpp =
	"\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

	" For perlomni.vim setting.
	" https://github.com/c9s/perlomni.vim
	let g:neocomplete#sources#omni#input_patterns.perl =
	\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

	" For smart TAB completion.
	"inoremap <expr><TAB>  pumvisible() ? "\<C-n>" :
	"        \ <SID>check_back_space() ? "\<TAB>" :
	"        \ neocomplete#start_manual_complete()
	"  function! s:check_back_space() "{{{
	"    let col = col('.') - 1
	"    return !col || getline('.')[col - 1]  =~ '\s'
	"  endfunction"}}}
<
==============================================================================
SOURCES						*neocomplete-sources*

neocomplete reads automatically sources saved in an
autoload/neocomplete/sources directory.

buffer						*neocomplete-source-buffer*
		This source collects keywords from buffer.

member						*neocomplete-source-member*
		This source collects use of member variables from buffer.

tag						*neocomplete-source-tag*
		This source analyzes a tag file from tagfiles() for completion.
		When a huge tag file (above
		|g:neocomplete#sources#tags#cache_limit_size|) is set,
		neocomplete does not make cache if you do not execute
		|:NeoCompleteTagMakeCache| command.  Because tag is
		too slow if tag read a big tags file.  You should use
		more convenient include completion now.

syntax						*neocomplete-source-syntax*
		This source analyzes a syntax file like
		autoload/syntaxcomplete.vim offered by default, and to
		add to candidate completion.  The plugin can recognize
		candidates a lot more than autoload/syntaxcomplete.vim.

include						*neocomplete-source-include*
		This source will add the file which an opening buffer
		refers to to candidate.  It is convenient, because you do
		not need to prepare a tags file and a dictionary file.
		But it is necessary for 'path' and 'include',
		'includeexpr' to be set adequately.

		Note: |vimproc| is required.
		http://github.com/Shougo/vimproc

vim						*neocomplete-source-vim*
		This source analyzes context and start Omni completion of
		Vim script.  This plugin does not work other than editing
		time of Vim script.  I created it because neocomplete
		cannot call |i_CTRL-X_CTRL-V|.  Local variable and a
		script variable, a function and the analysis of the
		command are implemented now.

dictionary					*neocomplete-source-dictionary*
		This source adds candidates from 'dictionary' or
		|g:neocomplete#sources#dictionary#dictionaries|.

file						*neocomplete-source-file*
		This source collects filename candidates.

file_include				*neocomplete-source-file/include*
		This source collects filename candidates.  It is useful
		when you input header file name.  It recognizes include
		pattern and include path like include.

omni						*neocomplete-source-omni*
		This source calls 'omnifunc' automatically when cursor
		text is matched with |g:neocomplete#sources#omni#input_patterns|.  If
		|g:neocomplete_omni_function_list|is defined,
		neocomplete will give priority it.


suffix of complete candidates in popup menu declaration.
(This will be good for user to know where candidate from and what it is.)

    file              -> [F] {filename}
    file/include      -> [FI] {filename}
    dictionary        -> [D] {words}
    member            -> [M] member
    buffer            -> [B] {buffername}
    syntax            -> [S] {syntax-keyword}
    include           -> [I]
    neosnippet        -> [neosnip]
    UltiSnips         -> [US]
    vim               -> [vim] type
    omni              -> [O]
    tag               -> [T]
    other sources     -> [plugin-name-prefix]

------------------------------------------------------------------------------
USER SOURCES 					*neocomplete-user-sources*

This section, introduce non default neocomplete sources.

neosnippet				*neocomplete-sources-neosnippet*
		This source is for snippets completion.
		https://github.com/Shougo/neosnippet

UltiSnips				*neocomplete-sources-ultisnips*
		This source is for UltiSnips snippets completion.
		https://github.com/SirVer/ultisnips

neco-ghc				*neocomplete-sources-neco-ghc*
		https://github.com/eagletmt/neco-ghc
		eagletmt originally implemented and ujihisa added some new
		features. It completes a source file written in Haskell.
		It requires ghc-mod <http://www.mew.org/~kazu/proj/ghc-mod/>.

==============================================================================
FILTERS						*neocomplete-filters*

To custom candidates, neocomplete uses the filters. There are three kinds of
filters are available. "matcher" is to filter candidates by user input.
"sorter" is to sort candidates. "converter" is to candidates conversion.

Default sources are below. But you can create original filters(cf:
|neocomplete-create-filter|) and set them by
|neocomplete#custom#source()|.
>
	call neocomplete#custom#source(
	\ 'buffer', 'converters', [])

	" Change default matcher.
	call neocomplete#custom#source('_', 'matchers',
	\ ['matcher_head', 'matcher_length'])

	" Change default sorter.
	call neocomplete#custom#source('_', 'sorters',
	\ ['sorter_length'])

	" Disable sort.
	call neocomplete#custom#source('_', 'sorters', [])

	" Change default converter.
	call neocomplete#custom#source('_', 'converters',
	\ ['converter_remove_overlap', 'converter_remove_last_paren',
        \  'converter_delimiter', 'converter_case', 'converter_abbr'])
<
					*neocomplete-filter-matcher_default*
Default matchers:
	if |g:neocomplete#enable_fuzzy_completion| :
		['matcher_head', 'matcher_length']
	else :
		['matcher_fuzzy', 'matcher_length']

					*neocomplete-filter-sorter_default*
Default sorters: ['sorter_rank'].

					*neocomplete-filter-converter_default*
Default converters: ['converter_remove_overlap',
        \      'converter_delimiter', 'converter_case', 'converter_abbr'].

					*neocomplete-filter-matcher_head*
matcher_head	Head matching matcher.

					*neocomplete-filter-matcher_fuzzy*
matcher_fuzzy	Fuzzy matching matcher.

					*neocomplete-filter-matcher_length*
matcher_length	Input keyword length matcher. It removes candidates which is
		less than input keyword length.

					*neocomplete-filter-sorter_rank*
sorter_rank	Matched rank order sorter.  The higher the matched word is
		already selected or in current buffer

					*neocomplete-filter-sorter_length*
sorter_length	Candidates length order sorter.

					*neocomplete-filter-sorter_word*
sorter_word	Candidates word order sorter.

					*neocomplete-filter-converter_abbr*
converter_abbr
		The converter which abbreviates a candidate's abbr.

				*neocomplete-filter-converter_disable_abbr*
converter_disable_abbr
		The converter which disables a candidate's abbr.

					*neocomplete-filter-converter_case*
converter_case
		The converter which converts a candidate's word in text mode.
		(cf: |g:neocomplete#text_mode_filetypes|)

				*neocomplete-filter-converter_delimiter*
converter_delimiter
		The converter which abbreviates a candidate's delimiter.
		(cf: |g:neocomplete#delimiter_patterns|)

			*neocomplete-filter-converter_remove_overlap*
converter_remove_overlap
		The converter which removes overlapped text in a candidate's
		word.
		Note: It removes candidates which is not overlapped
		(it is in auto completion only).

			*neocomplete-filter-converter_remove_last_paren*
converter_remove_last_paren
		The converter which removes last parentheses in a
		candidate's word. It is useful if you use auto closing
		parentheses plugins.

==============================================================================
CREATE SOURCE					*neocomplete-create-source*

In this clause, I comment on a method to make source of neocomplete.  The
ability of neocomplete will spread by creating source by yourself.

The files in autoload/neocomplete/sources are automatically loaded and it
calls neocomplete#sources#{source_name}#define() whose return value is the
source.  Each return value can be a list so you can return an empty list to
avoid adding undesirable sources.  To add your own sources dynamically, you
can use |neocomplete#define_source()|.

------------------------------------------------------------------------------
SOURCE ATTRIBUTES			*neocomplete-source-attributes*

					*neocomplete-source-attribute-name*
name			String				(Required)
			The name of a source.  Allowed characters are:
			- a-z
			- 0-9
			- _
			- /
			- - (Not head)

					*neocomplete-source-attribute-kind*
kind			String				(Optional)
			The kind of the source.  It decides the behaviour of
			the complete position.  The following values are
			available:

			"manual" : The source decides the complete position
				manually with the "get_complete_position"
				attribute.  See also:
				|neocomplete-source-attribute-get_complete_position|

			"keyword": The source decides the complete position
				with |g:neocomplete#keyword_patterns|.  This
				pattern is also used to filter the candidates.

			Note that "plugin", "complfunc" and "ftplugin" are old
			values that are no longer accepted.


				*neocomplete-source-attribute-filetypes*
filetypes		Dictionary			(Optional)
			Available filetype dictionary.

			For example:
>
			let source = {
			      \ 'name' : 'test',
			      \ 'kind' : 'manual',
			      \ 'filetypes' : { 'vim' : 1, 'html' : 1 },
			      \}
<
			The source is available in vim and html filetypes.

			If you omit it, this source available in all
			filetypes.

			*neocomplete-source-attribute-disabled_filetypes*
disabled_filetypes		Dictionary		(Optional)
			Not available filetype dictionary.
			If the key is "_", the source is disabled in all
			sources.

					*neocomplete-source-attribute-rank*
rank			Number				(Optional)
			Source priority.

			If you omit it, it is set below value.
			If kind attribute is "keyword" : 5
			If filetype attribute is empty : 10
			Else : 100

			*neocomplete-source-attribute-min_pattern_length*
min_pattern_length
			Number				(Optional)
			Required pattern length for completion.

			If you omit it, it is set below value.
			If kind attribute is "keyword" :
			    |g:neocomplete#auto_completion_start_length|
			Else : 0

			*neocomplete-source-attribute-max_candidates*
max_candidates
			Number		(Optional)
			The maximum number of candidates.

			This attribute is optional; if it is not given,
			0 is used as the default value.  This means
			maximum number is infinity.

			*neocomplete-source-attribute-keyword_patterns*
keyword_patterns
			Dictionary	(Optional)
			This dictionary changes keyword patterns to
			completion for specific types.
>
	let keyword_patterns = {}
	let keyword_patterns.tex = '\\\?\h\w*'
	call neocomplete#custom#source('dictionary',
	\ 'keyword_patterns', keyword_patterns)
<
			This attribute is optional; if it is not given,
			|g:neocomplete#keyword_patterns| is used as the
			default value.

				*neocomplete-source-attribute-is_volatile*
is_volatile		Number		(Optional)
			Whether the source recalculates the candidates
			everytime the input is changed.
			This attribute is optional.
			If it's not given, 0 is set as the default value.  In
			this case, candidates are cached.

				*neocomplete-source-attribute-disabled*
disabled		Number		(Optional)
			This attribute is optional.
			If it's not given, 0 is set as the default value.
			Otherwise, the source is disabled.

					*neocomplete-source-attribute-hooks*
hooks			Dictionary		(Optional)
			You may put hook functions in this dictionary in which
			the key is the position to hook and the value is the
			reference to the function to be called.  The following
			hook functions are defined:

				*neocomplete-source-attribute-hooks-on_init*
			on_init
			Called when initializing the source.
			This function takes {context} as its parameters.

				*neocomplete-source-attribute-hooks-on_final*
			on_final
			Called after executing |:NeoCompleteDisable|.
			This function takes {context} as its parameters.

			*neocomplete-source-attribute-hooks-on_post_filter*
			on_post_filter
			Called after the filters to narrow down the
			candidates.  This is used to set attributes. This
			filters is to avoid adversely affecting the
			performance.
			This function takes {context} as its parameters.

			*neocomplete-source-attribute-get_complete_position*
get_complete_position	Function	(Optional)
			This function takes {context} as its
			parameter and returns complete position in current
			line.
			Here, {context} is the context information when the
			source is called(|neocomplete-notation-{context}|).
			If you omit it, neocomplete will use the position
			using |g:neocomplete#keyword_patterns|.
			Note: If the source returns candidates which are not
			matched |g:neocomplete#keyword_patterns|, you must
			define
			|neocomplete-source-attribute-get_complete_position|.

			*neocomplete-source-attribute-gather_candidates*
gather_candidates	Function	(Required)
			This function is called in gathering candidates.  If
			you enabled fuzzy completion by
			|g:neocomplete#enable_fuzzy_completion| , this
			function is called whenever the input string is
			changed.  This function takes {context} as its
			parameter and returns a list of {candidate}.
			Here, {context} is the context information when the
			source is called(|neocomplete-notation-{context}|).

{context}				*neocomplete-notation-{context}*
			A dictionary to give context information.
			The followings are the primary information.
			The global context information can be acquired
			by |neocomplete#get_context()|.

			input			(String)
				The input string of current line.

			complete_pos		(Number)
				The complete position of current source.

			complete_str		(String)
				The complete string of current source.

			source__{name}		(Unknown)	(Optional)
				Additional source information.
				Note: Recommend sources save
				variables instead of s: variables.

------------------------------------------------------------------------------
CANDIDATE ATTRIBUTES			*neocomplete-candidate-attributes*

				*neocomplete-candidate-attribute-name*
word			String		(Required)
			The completion word of a candidate. It is used for
			matching inputs.

				*neocomplete-candidate-attribute-abbr*
abbr			String		(Optional)
			The abbreviation of a candidate. It is displayed in
			popup window. It is omitted by
			|g:neocomplete#max_keyword_width|.

				*neocomplete-candidate-attribute-kind*
kind			String		(Optional)
			The kind of a candidate. It is displayed in popup
			window.

				*neocomplete-candidate-attribute-menu*
menu			String		(Optional)
			The menu information of a candidate. It is displayed
			in popup window.

				*neocomplete-candidate-attribute-info*
info			String		(Optional)
			The preview information of a candidate. If
			'completeopt' contains "preview", it will be displayed
			in |preview-window|.

				*neocomplete-candidate-attribute-rank*
rank			Number		(Optional)
			The completion priority.

CONTEXT						*neocomplete-context*

==============================================================================
CREATE FILTER					*neocomplete-create-filter*

The files in autoload/neocomplete/filters are automatically loaded and it
calls neocomplete#filters#{filter_name}#define() whose return value is the
filter.  Each return value can be a list so you can return an empty list to
avoid adding undesirable filters.  To add your own filters dynamically, you
can use |neocomplete#define_filter()|.

------------------------------------------------------------------------------
FILTER ATTRIBUTES			*neocomplete-filter-attributes*


					*neocomplete-filter-attribute-name*
name			String		(Required)
			The filter name.

					*neocomplete-filter-attribute-filter*
filter			Function		(Required)
			The filter function.  This function takes {context} as
			its parameter and returns a list of {candidate}.
			The specification of the parameters and the returned
			value is same as
			|neocomplete-source-attribute-gather_candidates|.

					*neocomplete-filter-attribute-description*
description		String		(Optional)
			The filter description string.

==============================================================================
UNITE SOURCES					*neocomplete-unite-sources*

				*neocomplete-unite-source-neocomplete*
neocomplete
		Nominates neocomplete completion candidates.  The kind is
		"completion".  This source is used in
		|<Plug>(neocomplete_start_unite_complete)|.
>
		imap <C-k>  <Plug>(neocomplete_start_unite_complete)
		imap <C-q>  <Plug>(neocomplete_start_unite_quick_match)
<
==============================================================================
EXTERNAL SOURCES				*neocomplete-external-sources*

neosnippet source :

https://github.com/Shougo/neosnippet.vim

UltiSnips source :

https://github.com/SirVer/ultisnips

vimshell source :

https://github.com/Shougo/vimshell.vim

look source :

https://github.com/ujihisa/neco-look

ghc source :

https://github.com/eagletmt/neco-ghc

calc source :

https://github.com/hrsh7th/vim-neco-calc

==============================================================================
FAQ						*neocomplete-faq*

Q: My customization for neocomplete is invalid. Why?

A: User customization for neocomplete must be set before initialization of
neocomplete. For example: |neocomplete#custom#source()|

Q: I want to use head match instead of default fuzzy match.

A:
>
	let g:neocomplete#enable_fuzzy_completion = 0
<
or
>
	call neocomplete#custom#source('_', 'matchers',
	\ ['matcher_head', 'matcher_length'])
<
Q: I want to sort candidates by different way.

A:
>
>
	call neocomplete#custom#source('_', 'sorters',
	\ ['sorter_length'])
<
Q: Is there a way to control the colors used for popup menu using highlight
groups?:

A: Like this:
>
	highlight Pmenu ctermbg=8 guibg=#606060
	highlight PmenuSel ctermbg=1 guifg=#dddd00 guibg=#1f82cd
	highlight PmenuSbar ctermbg=0 guibg=#d6d6d6
<

Q: Python (or Ruby) interface crashes Vim when I use neocomplete or not
responding when input ".":

A: This is not neocomplete's issue.  Please report to the maintainers of the
omnicomplete (rubycomplete or pythoncomplete) and its Vim interface.  You
should disable omni source in python or ruby.
>
	if !exists('g:neocomplete#sources#omni#input_patterns')
	  let g:neocomplete#sources#omni#input_patterns = {}
	endif
	let g:neocomplete#sources#omni#input_patterns.python = ''
	let g:neocomplete#sources#omni#input_patterns.ruby = ''
<

Q: I like moving cursor by cursor-keys.  But neocomplete popups menus...

A: Please set this in your .vimrc.
>
	let g:neocomplete#enable_insert_char_pre = 1
<

Q: Where are the snippets for neocomplete?

A: https://github.com/Shougo/neosnippet or
https://github.com/SirVer/ultisnips


Q: How can I disable python omni complete of neocomplete?:

A:
>
	if !exists('g:neocomplete#sources#omni#input_patterns')
	  let g:neocomplete#sources#omni#input_patterns = {}
	endif
	let g:neocomplete#sources#omni#input_patterns.python = ''
<

Q: Can I enable quick match? :

A: Quick match feature had been removed in latest neocomplete
because quick match turned into hard to implement.
But you can use |unite.vim| instead to use quick match.
>
	imap <expr> -  pumvisible() ?
	    \ "\<Plug>(neocomplete_start_unite_quick_match)" : '-'
<

Q: How can I change the order of candidates? :

A: Todo.

Q: An input problem occurred in using uim-skk or other IMEs:

A: It may be fixed with setting |g:neocomplete#enable_prefetch| as 1.


Q: include source does not work.

A: include source depends on |vimproc|.  I recommend you to install it.  Also
you can check 'path' option or change |g:neocomplete#sources#include#paths|.

http://github.com/Shougo/vimproc


Q: neocomplete cannot create cache files in "sudo vim":

A: Because neocomplete (and other plugins) creates temporary files in super
user permission by sudo command.  You must use sudo.vim or set "Defaults
always_set_home" in "/etc/sudoers", or must use "sudoedit" command.

Ubuntu has a command "sudoedit" which can work well with neocomplete.
I'm not sure if other distros has this command...

http://www.vim.org/scripts/script.php?script_id=729


Q: Error occurred in ruby omni complete using
|g:neocomplete#sources#omni#input_patterns|.
https://github.com/vim-ruby/vim-ruby/issues/95

A: Please set |g:neocomplete#force_omni_input_patterns| instead of
|g:neocomplete#sources#omni#input_patterns|.

Q: Does not work with clang_complete.

A: Please try below settings.
>
	if !exists('g:neocomplete#force_omni_input_patterns')
	  let g:neocomplete#force_omni_input_patterns = {}
	endif
	let g:neocomplete#force_overwrite_completefunc = 1
	let g:neocomplete#force_omni_input_patterns.c =
	      \ '[^.[:digit:] *\t]\%(\.\|->\)\w*'
	let g:neocomplete#force_omni_input_patterns.cpp =
	      \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
	let g:neocomplete#force_omni_input_patterns.objc =
	      \ '[^.[:digit:] *\t]\%(\.\|->\)\w*'
	let g:neocomplete#force_omni_input_patterns.objcpp =
	      \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
	let g:clang_complete_auto = 0
	let g:clang_auto_select = 0
	"let g:clang_use_library = 1
<

Q: I want to support omni patterns for external plugins.

A: You can add find some already found omni patterns and functions at here.

Note: Some patterns are omitted here, (someone should check out those plugin's
source code's complete function, and find out the omni pattern).
>
	" Go (plugin: gocode)
	let g:neocomplete#sources#omni#functions.go =
	\ 'gocomplete#Complete'
	" Clojure (plugin: vim-clojure)
	let g:neocomplete#sources#omni#functions.clojure =
	\ 'vimclojure#OmniCompletion'
	" SQL
	let g:neocomplete#sources#omni#functions.sql =
	\ 'sqlcomplete#Complete'
	" R (plugin: vim-R-plugin)
	let g:neocomplete#sources#omni#input_patterns.r =
	\ '[[:alnum:].\\]\+'
	let g:neocomplete#sources#omni#functions.r =
	\ 'rcomplete#CompleteR'
	" XQuery (plugin: XQuery-indentomnicomplete)
	let g:neocomplete#sources#omni#input_patterns.xquery =
	\ '\k\|:\|\-\|&'
	let g:neocomplete#sources#omni#functions.xquery =
	\ 'xquerycomplete#CompleteXQuery'
<

Q: Does not indent when I input "else" in ruby filetype.

A:

You must install "vim-ruby" from github to indent in neocomplete first.
https://github.com/vim-ruby/vim-ruby

neocomplete pops up a completion window automatically, but if the popup
window is already visible, Vim cannot indent text.  So you must choose "close
popup window manually by <C-y> or <C-e> mappings" or "close popup window by
<CR> user mappings".

Q: <CR> mapping conflicts with |SuperTab| or |endwise| plugins.

A: Please try below settings.
>
	" <CR>: close popup and save indent.
	inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
	function! s:my_cr_function()
	  return neocomplete#close_popup() . "\<CR>"
	  " For no inserting <CR> key.
	  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
	endfunction
>
Q: No completion offered from "vim" buffers in "non-vim" buffers.

A: It is feature. neocomplete completes from same filetype buffers in
default.  But you can completes from other filetype buffers using
|g:neocomplete#same_filetypes|.

Q: I want to complete from all buffers.

A: |g:neocomplete#same_filetypes|
>
	let g:neocomplete#same_filetypes = {}
	let g:neocomplete#same_filetypes._ = '_'
<

Q: Suggestions are case insensitive in "gitcommit" buffers, but not
"javascript".

A: This is g:neocomplete#text_mode_filetypes feature.
You can disable it by following code.
>
	if !exists('g:neocomplete#text_mode_filetypes')
	  let g:neocomplete#tags_filter_patterns = {}
	endif
	let g:neocomplete#text_mode_filetypes.gitcommit = 0
<
Q: Conflicts completefunc with other plugins in neocomplete.

A: You can disable the error by |g:neocomplete#force_overwrite_completefunc|
variable to 1.

Q: I want to use Ruby omni completion.

A: Please set |g:neocomplete#force_omni_input_patterns|.  But this completion
is heavy, so disabled by default.
Note: But you should use |neocomplete-rsense| instead of rubycomplete.
https://github.com/Shougo/neocomplete-rsense
>
	autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
	if !exists('g:neocomplete#force_omni_input_patterns')
	  let g:neocomplete#force_omni_input_patterns = {}
	endif
	let g:neocomplete#force_omni_input_patterns.ruby =
	\ '[^. *\t]\.\w*\|\h\w*::'
<
Q: I want to use jedi omni completion.
https://github.com/davidhalter/jedi-vim

A: Please set |g:neocomplete#force_omni_input_patterns| as below.
>
	autocmd FileType python setlocal omnifunc=jedi#completions
	let g:jedi#completions_enabled = 0
	let g:jedi#auto_vim_configuration = 0
	let g:neocomplete#force_omni_input_patterns.python =
	\ '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
<
Q: Candidates are not found in heavy completion(neco-look, etc).

A: It may be caused by skip completion.


Q: I want to disable skip completion.

A:
>
	let g:neocomplete#skip_auto_completion_time = ''
<
Q: I want to initialize neocomplete in .vimrc.

A: Please call neocomplete#initialize() in .vimrc.  But this function slows
your Vim initialization.
>
	call neocomplete#initialize()
<
Q: neocomplete conflicts when multibyte input in GVim.

A: Because Vim multibyte IME integration is incomplete.
If you set |g:neocomplete#lock_iminsert| is non-zero, it may be fixed.

Q: Freeze for a while and close opened folding when I begin to insert.
https://github.com/Shougo/neocomplcache.vim/issues/368

A: I think you use 'foldmethod' is "expr" or "syntax". It is too heavy to use
neocomplete(or other auto completion). You should change 'foldmethod'
option.
Note: In current version, neocomplete does not restore 'foldmethod'. Because
it is too heavy.

Q: I want to use Pydiction with neocomplete.

A: You should set |g:neocomplete#sources#dictionary#dictionaries|.
neocomplete can load Pydiction dictionary file.

Q: Why does neocomplcache use if_lua besides if_python? Many people may not be
able to use it because they do not have the root privilege to recompile vim.

A:
Because of the following reasons.
 1. Python interface is not available on every Vim environment. For example,
 Android, iOS, non configured Vim, or etc.
 2. Incompatibility between Python2 and Python3. I must rewrite for it.
 3. Loading Python interface is slow (10~20ms), but loading Lua interface is
 absolutely fast (270ns).
 4. Python2 and Python3 are not loaded at the same time on Unix environment.
 5. Python itself is too large.
 6. Python interface is slower than Lua interface (almost twice.)
 7. Lua interface is stable (no crashes on latest Vim.)
 8. Using C module (like vimproc, YouCompleteMe) is hard to compile on Windows
 environment.
 9. Using both Python and C, like YouCompleteMe, is too unstable. Your Vim may
 crashes or causes mysterious errors.
 10. To build if_lua is easy.
 11. I think if_lua is the second level language in Vim (The first is Vim
 script.)

Q: I want to disable preview window.

A:
>
	set completeopt-=preview
<

Q: I want to use "vim-lua-ftplugin".
https://github.com/xolox/vim-lua-ftplugin

A: Please set |g:neocomplete#sources#omni#input_patterns| as below.
Note: You can not use "vim-lua-ftplugin" on 7.3.885 or below,
because if_lua has double-free problem.
>
	let g:lua_check_syntax = 0
	let g:lua_complete_omni = 1
	let g:lua_complete_dynamic = 0

	let g:neocomplete#sources#omni#functions.lua =
	      \ 'xolox#lua#omnifunc'
	let g:neocomplete#sources#omni#input_patterns.lua =
	      \ '\w\+[.:]\|require\s*(\?["'']\w*'
	" let g:neocomplete#force_omni_input_patterns.lua =
	      " \ '\w\+[.:]\|require\s*(\?["'']\w*'
<

Q: I want to disable sources in certain filetype.

A:
>
	" Disable dictionary source in python filetype.
	call neocomplete#custom#source('dictionary',
	\ 'disabled_filetypes', {'python' : 1})
<

Q: neocomplete closes DiffGitCached window from vim-fugitive
https://github.com/Shougo/neocomplcache.vim/issues/424
A:
>
	let g:neocomplete#enable_auto_close_preview = 0
<
Q: I want to refresh candidates like |YouCompleteMe|.
A:
Note: This feature is heavy.
>
	let g:neocomplete#enable_refresh_always = 1
<

Q: neocomplete auto select feature is not worked. Why?
A: You should enable refresh always feature.
>
	let g:neocomplete#enable_auto_select = 1
	let g:neocomplete#enable_refresh_always = 1
<

Q: I want to use PHP omni completion.

A:
Note: You should use this omni completion for PHP.
https://github.com/shawncplus/phpcomplete.vim
>
	let g:neocomplete#sources#omni#input_patterns.php =
	\ '\h\w*\|[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
<

Q: Eclim does not work well with neocomplete.
https://github.com/Shougo/neocomplete.vim/issues/39

A: neocomplete does not support eclim.  You should use
|g:neocomplete#force_omni_input_patterns| instead of
|g:neocomplete#sources#omni#input_patterns|.
>
	if !exists('g:neocomplete#force_omni_input_patterns')
	  let g:neocomplete#force_omni_input_patterns = {}
	endif
	g:neocomplete#force_omni_input_patterns.java =
	\ \'\%(\h\w*\|)\)\.\w*

Q: I want to get quiet messages in auto completion.
https://github.com/Shougo/neocomplcache.vim/issues/448

A: It is impossible. Because it is Vim's feature.
Vim is not intended for auto completion.

But you can configure it by below settings.
>
	autocmd VimEnter *
	\ highlight ModeMsg guifg=bg guibg=bg | highlight WarningMsg guifg=bg
<

Q: I don't want to complete too long words.
https://github.com/Shougo/neocomplete.vim/issues/69

A: You can use |g:neocomplete#sources#buffer#max_keyword_width|.

Q: neocomplete will change external completeopt value(longest).
https://github.com/Shougo/neocomplcache.vim/issues/453

A: It is feature. Because "longest" completeopt conflicts with auto
completion.  To use "longest" option, you must disable auto completion.
"longest" is good feature. But it is for manual completion only.

Q: Auto completion does not work in ruby filetype with error messages.
https://github.com/tpope/vim-rails/issues/283

A: It is vim-rails problem. Not neocomplete.

https://github.com/tpope/vim-rails/blob/master/autoload/rails.vim#L4468

vim-rails overwrites completefunc. So neocomplete disabled.
You can overwrite completefunc by
|g:neocomplete#force_overwrite_completefunc|.

Q: autoclose conflicts with neocomplete.
https://github.com/Shougo/neocomplcache.vim/issues/350

A: It is autoclose mappings problem. I cannot fix it. You should use
auto-pairs plugin instead of it.
https://github.com/jiangmiao/auto-pairs

Q: I want to move to cursor by arrow key.
https://github.com/Shougo/neocomplete.vim/issues/114

A: First, I don't recommend to move cursor by arrow key. It is not Vim's
theory. But if you want to move cursor forcely, you can config it by following
settings. >

	" For cursor moving in insert mode(Not recommended)
	"inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
	"inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
	"inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
	"inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
	" Or set this.
	"let g:neocomplete#enable_cursor_hold_i = 1
	" Or set this.
	"let g:neocomplete#enable_insert_char_pre = 1

Q: I want to complete by Erlang omnifunc.
https://github.com/vim-erlang/vim-erlang-omnicomplete

A: >
	if !exists('g:neocomplete#force_omni_input_patterns')
	  let g:neocomplete#force_omni_input_patterns = {}
	endif
	g:neocomplete#force_omni_input_patterns.erlang =
	\ '\<[[:digit:][:alnum:]_-]\+:[[:digit:][:alnum:]_-]*'

Q: I want to complete candidates from header files.
https://github.com/Shougo/neocomplete.vim/issues/118

A: You can do it by |neocomplete-source-include|, but you must install
|vimproc|.
		http://github.com/Shougo/vimproc.vim

Q: I want to look selected function's arguments in neocomplete. But I don't
like preview window feature.
https://github.com/Shougo/neocomplete.vim/issues/120

A: You can do it by |echodoc|.
http://github.com/Shougo/echodoc.vim
Note: This feature is available from neocomplete candidates only.
You cannot get it from |g:neocomplete#force_omni_input_patterns|.

Q: In ||g:neocomplete#force_omni_input_patterns|,
|g:neocomplete#enable_auto_select| feature is not work.
https://github.com/Shougo/neocomplete.vim/issues/139

A: It is feature. See |g:neocomplete#force_omni_input_patterns| documentation.

Q: I want to disable all sources by default.

A: >
	call neocomplete#custom#source('_', 'disabled', 1)

Q: I want to disable candidates abbr in tag source.
https://github.com/Shougo/neocomplete.vim/issues/158

A: >
	call neocomplete#custom#source('tags', 'converters',
	\ ['converter_remove_overlap', 'converter_remove_last_paren',
	\  'converter_delimiter', 'converter_case',
	\ 'converter_disable_abbr', 'converter_abbr'])

==============================================================================
vim:tw=78:ts=8:ft=help:norl:noet:fen:noet:
